# Chapter 03: 순수 함수로 얻는 순수한 행복

## 다시 순수해질 수 있다면

우리는 먼저 순수 함수에 대한 개념을 명확히 해야 합니다.

> 순수 함수란, 동일한 입력이 주어졌을 때 항상 동일한 출력을 반환하며, 관찰 가능한 부작용(side effect)이 없는 함수입니다.

예를 들어, `slice`와 `splice`를 살펴봅시다. 이 두 함수는 겉보기에는 같은 작업을 수행합니다. 물론 내부적으로는 완전히 다른 방식으로 동작하지만, 어쨌든 동일한 작업입니다. 여기서 `slice`는 입력에 대해 항상 동일한 출력을 반환하기 때문에 _순수_ 하다고 말합니다. 하지만 `splice`는 배열을 씹어 삼킨 뒤 영원히 변해버린 상태로 반환합니다. 이것은 관찰 가능한 효과입니다.

```js
const xs = [1, 2, 3, 4, 5];

// pure
xs.slice(0, 3); // [1,2,3]

xs.slice(0, 3); // [1,2,3]

xs.slice(0, 3); // [1,2,3]

// impure
xs.splice(0, 3); // [1,2,3]

xs.splice(0, 3); // [4,5]

xs.splice(0, 3); // []
```

함수형 프로그래밍에서는 `splice`처럼 데이터를 _변형(mutate)_ 하는 다루기 힘든 함수들을 좋아하지 않습니다. 우리는 매번 동일한 결과를 반환하는 신뢰할 수 있는 함수를 지향하지, `splice` 처럼 흔적을 남기고 엉망으로 만드는 함수들을 원하지 않습니다.

다른 예제를 살펴봅시다.

```js
// 순수하지 않은 예시
let minimum = 21;
const checkAge = (age) => age >= minimum;

// 순수한 예시
const checkAge = (age) => {
  const minimum = 21;
  return age >= minimum;
};
```

순수하지 않은 예시에서 `checkAge`는 결과를 결정하기 위해 변경 가능한 변수인 `minimum`에 의존합니다. 다시 말해, 시스템 상태에 의존하고 있다는 뜻인데, 이는 실망스러운 일입니다. 왜냐하면 외부 환경을 도입함으로써 [인지 부하](https://en.wikipedia.org/wiki/Cognitive_load)를 증가시키기 때문입니다.

이 예시에서는 별일 아닌 것처럼 보일 수도 있지만, 이러한 상태에 대한 의존성은 시스템 복잡성을 증가시키는 가장 큰 요인 중 하나입니다 (http://curtclifton.net/papers/MoseleyMarks06a.pdf). 이 `checkAge` 함수는 입력 이외의 외부 요소에 따라 서로 다른 결과를 반환할 수 있기 때문에, 순수하지 않을 뿐만 아니라, 우리가 소프트웨어를 이해하려 할 때마다 머리를 쥐어짜게 만듭니다.

반면 순수한 형태의 `checkAge`는 완전히 자립적입니다. 또한 `minimum`을 불변으로 만들어 상태가 절대 변하지 않도록 하면 순수성을 유지할 수 있습니다. 이를 위해선 동결된 객체를 생성해야 합니다.

```js
const immutableState = Object.freeze({ minimum: 21 });
```

## 부작용은 다음과 같습니다...

이제 "부작용(side effects)"이라는 것에 대해 좀 더 살펴보면서 우리의 직관을 키워봅시다. 그렇다면 _순수 함수_ 의 정의에서 언급된 이 의심스러운 _부작용_ 이란 도대체 무엇일까요? 우리는 여기서 _효과_ 를 결과를 계산하는 것 이외에 계산 과정에서 발생하는 모든 것으로 간주할 것입니다.

효과 자체가 본질적으로 나쁜 것은 아닙니다. 사실 이후의 장들에서도 우리는 이런 효과를 다양하게 활용할 것입니다. 부정적인 뉘앙스를 가지는 것은 바로 그 앞에 붙은 "부(side)"라는 말입니다. 물 자체는 애벌레의 자연적 번식지가 아닙니다. 문제는 물이 _고여_ 있을 때이고, 이때 모기 떼가 들끓게 되죠. _부작용_ 도 여러분의 프로그램 안에서 비슷한 번식지를 형성하게 됩니다. 믿어도 좋습니다.

> _부작용(side effect)_ 이란, 결과를 계산하는 과정 중에 발생하는 시스템 상태의 변화 또는 외부 세계와의 _관찰 가능한 상호작용_ 을 말합니다.

부작용에는 다음과 같은 것들이 포함될 수 있으며, 이에 국한되지 않습니다 :

- 파일 시스템 변경
- 데이터베이스에 레코드 삽입
- HTTP 호출
- 데이터의 변형(Mutation)
- 화면 출력 / 로그 출력
- 사용자 입력 받기
- DOM 쿼리
- 시스템 상태에 접근

그리고 이 목록은 끝이 없습니다. 함수 외부 세계와의 모든 상호작용은 부작용이며, 이 사실은 여러분으로 하여금 "부작용 없이 과연 실용적인 프로그래밍이 가능한가?"라는 의문을 갖게 만들 수 있습니다. 함수형 프로그래밍의 철학은 부작용이 잘못된 동작의 주요 원인이라는 전제 위에 서 있습니다.

부작용을 사용하는 것이 금지된 것은 아닙니다. 오히려 우리는 부작용을 통제된 방식으로 한정하여 실행하려고 합니다. 이 방법에 대해서는 후속 장에서 functor와 monad를 배우면서 다를 예정입니다. 하지만 지금은 이러한 교활할 함수들을 순수 함수와 구분하려고 노력해봅시다.

부작용은 함수를 순수 함수로 만들지 못하게 합니다. 그 이유는 분명합니다. 순수 함수는 정의상 동일한 입력에 대해 항상 동일한 출력을 반환해야 하는데, 이는 함수 외부의 사항을 다룰 때 보장할 수 없습니다.

이제 왜 우리가 동일한 입력에 대해 동일한 출력을 고집하는 지 좀 더 자세히 살펴봅시다. 자, 카라를 세우고, 8학년 수학을 살펴보겠습니다.

## 8학년 수학

mathisfun.com에서:

> 함수는 값들 간의 특별한 관계입니다. 각 입력 값은 정확히 하나의 출력 값을 반환합니다.

다시 말해, 함수는 입력과 출력이라는 두 값 간의 관계에 불과합니다. 각 입력에 대해 정확히 하나의 출력이 존재하지만, 그 출력이 반드시 입력마다 고유할 필요는 없습니다. 아래는 `x`에서 `y`로 가는 완벽하게 유효한 함수의 다이어그램을 보여줍니다.

<img src="images/function-sets.gif" alt="function sets" />(https://www.mathsisfun.com/sets/function.html)

대조적으로 아래 다이어그램은 입력 값 `5`가 여러 개의 출력 값으로 연결되어 있기 때문에 함수가 _아닌_ 관계를 보여줍니다.

<img src="images/relation-not-function.gif" alt="relation not function" />(https://www.mathsisfun.com/sets/function.html)

함수는 입력과 출력의 쌍으로 이루어진 집합으로 설명될 수 있습니다 : `[(1,2), (3,6), (5,10)]` (이 함수는 입력 값을 두 배로 만드는 함수처럼 보입니다).

혹은 아래와 같은 표로 나타낼 수도 있습니다 :

<table> <tr> <th>Input</th> <th>Output</th> </tr> <tr> <td>1</td> <td>2</td> </tr> <tr> <td>2</td> <td>4</td> </tr> <tr> <td>3</td> <td>6</td> </tr> </table>

혹은 `x`를 입력 값으로, `y`를 출력 값으로 하는 그래프로도 표현할 수 있습니다 :

<img src="images/fn_graph.png" width="300" height="300" alt="function graph" />

입력이 출력을 결정한다면 구현 세부 사항은 필요하지 않습니다. 함수는 단순히 입력을 출력으로 매핑하는 것이기 때문에 객체 리터럴을 적어두고 `()` 대신 `[]`로 실행할 수 있습니다.

```js
const toLowerCase = {
  A: "a",
  B: "b",
  C: "c",
  D: "d",
  E: "e",
  F: "f",
};
toLowerCase["C"]; // 'c'

const isPrime = {
  1: false,
  2: true,
  3: true,
  4: false,
  5: true,
  6: false,
};
isPrime[3]; // true
```

물론, 계산을 하고 싶을 수도 있겠지만, 이는 함수를 생각하는 다른 방식의 예시를 보여줍니다. (여러분은 "여러 개의 인수를 가진 함수는 어떻게 하나요?"라고 생각할 수도 있습니다. 맞습니다. 이것은 수학적으로 생각할 때 조금 불편함을 주기도 합니다. 지금은 이를 배열에 묶거나 `arguments` 객체를 입력으로 생각하면 됩니다. 나중에 _커링(currying)_ 에 대해 배우면서 함수의 수학적 정의를 어떻게 직접 모델링할 수 있는지 알게 될 것입니다.)

이제 본격적으로 밝혀집니다 : 순수 함수는 _수학적 함수_ 이며, 바로 이것이 함수형 프로그래밍의 핵심입니다. 이러한 작은 천사들과 프로그래밍을 하면 큰 이점을 얻을 수 있습니다. 이제 순수를 유지하려고 우리가 왜 이렇게 많은 노력을 기울이는지 몇 가지 이유를 살펴보겠습니다.

## 순수성의 장점

### 캐시 가능

우선, 순수 함수는 항상 입력에 따라 캐시될 수 있습니다. 이는 일반적인 메모이제이션(memoization)이라는 기법을 사용하여 이루어집니다 :

```js
const squareNumber = memoize((x) => x * x);

squareNumber(4); // 16

squareNumber(4); // 16, returns cache for input 4

squareNumber(5); // 25

squareNumber(5); // 25, returns cache for input 5
```

여기 간단한 구현 예시가 있습니다만, 더 강력한 버전들도 많이 존재합니다.

```js
const memoize = (f) => {
  const cache = {};

  return (...args) => {
    const argStr = JSON.stringify(args);
    cache[argStr] = cache[argStr] || f(...args);
    return cache[argStr];
  };
};
```

주목할 점은 일부 비순수 함수들을 평가를 지연시켜 순수 함수로 변환할 수 있다는 것입니다 :

```js
const pureHttpCall = memoize((url, params) => () => $.getJSON(url, params));
```

여기서 흥미로운 점은 실제로 HTTP 호출을 하지 않는다는 것입니다. 대신 호출될 때 HTTP 호출을 실행하는 함수를 반환합니다. 이 함수는 순수 함수입니다. 왜냐하면 동일한 입력에 대해 항상 동일한 출력을 반환하기 때문입니다. `url`과 `params`에 따라 특정 HTTP 호출을 실행할 함수가 반환됩니다.

우리의 `memoize` 함수는 잘 작동하지만, HTTP 호출 결과를 캐시하는 것이 아니라 생성된 함수를 캐시합니다.

현재로서는 그다지 유용하지 않지만, 곧 이를 유용하게 만드는 몇 가지 기술을 배울 것입니다. 핵심은 그 함수가 아무리 파괴적일지라도 모든 함수를 캐시할 수 있다는 점입니다.

### 이식성 / 자기 문서화

순수 함수는 완전히 독립적입니다. 함수가 필요로 하는 모든 것은 은접시에 담겨 제공됩니다. 잠시 생각해 보세요... 이것이 어떻게 유용할 수 있을까요? 우선, 함수의 의존성은 명시적이기 때문에 더 쉽게 확인하고 이애할 수 있습니다. 함수 내부에서 불필요한 복잡한 일이 일어나지 않기 때문입니다.

```js
// impure
const signUp = (attrs) => {
  const user = saveUser(attrs);
  welcomeUser(user);
};

// pure
const signUp = (Db, Email, attrs) => () => {
  const user = saveUser(Db, attrs);
  welcomeUser(Email, user);
};
```

여기 예시는 순수 함수가 자신의 의존성에 대해 정직해야 한다는 것을 보여줍니다. 즉, 함수가 무엇을 하는지 정확히 알려줍니다. 함수의 시그니처만 봐도 `Db`,`Email`,`attrs`를 사용한다는 것을 알 수 있습니다. 이 정도면 충분히 설명적이라고 할 수 있습니다.

우리는 평가를 지연시키는 것만으로 순수 함수를 만드는 방법을 배울 것이지만, 중요한 점은 순수 함수 형태가 그 자체로 비순수 함수보다 훨씬 더 많은 정보를 제공한다는 것입니다. 비순수 함수는 무엇을 하는지 알 수 없으니까요.

또한 주목할 점은 우리는 의존성을 "주입"하거나 인수로 전달해야 한다는 것입니다. 이렇게 하면 데이터베이스나 메일 클라이언트 등을 매개변수화 했기 때문에 앱이 훨씬 더 유연해집니다. (걱정하지 마세요, 이 과정을 덜 지루하게 만드는 방법을 곧 배울 것입니다.) 만약 다른 `Db`를 사용하고 싶다면, 그 `Db`와 함께 호출하면 됩니다. 또한 새로운 애플리케이션에서 이 신뢰할 수 있는 함수를 재사용하고 싶다면, 그때 필요한 `Db`와 `Email`을 함수에 넘겨주기만 하면 됩니다.

자바스크립트 환경에서는 이식성(Portability)이란 함수를 직렬화해서 소켓을 통해 보내는 것일 수도 있고, 모든 앱 코드를 웹 워커에서 실행하는 것일 수도 잇습니다. 이식성은 강력한 특성입니다.

상태, 의존성, 사용 가능한 효과에 의해 환경에 깊숙이 뿌리박힌 명령형 프로그래밍의 "전형적인" 방법들과 절차들과는 달리, 순수 함수는 우리가 원하는 곳에서 어디서든 실행할 수 있습니다.

마지막으로 메서드를 새 앱에 복사해 본게 언제였나요? 제가 좋아하는 명언 중 하나는 Erlang의 창시자인 Joe Armstrong의 말입니다 : "객체 지향 언어의 문제는 그들이 환경을 암묵적으로 끌고 다닌다는 것입니다. 당신은 바나나를 원했지만, 그 대신 바나나를 들고 있는 고릴라와 정글 전체를 가져온 셈이죠."

### 테스트 가능

다음으로, 순수 함수가 테스트를 훨씬 더 쉽게 만든다는 것을 깨닫게 됩니다. 우리는 매번 테스트마다 "실제" 결제 게이트웨이를 모킹하거나, 각 테스트 후에 세계의 상태를 설정하고 검증할 필요가 없습니다. 함수에 입력값만 제공하고, 그에 따른 출력을 검증하면 됩니다.

실제로, 우리는 함수형 커뮤니티가 생성된 입력으로 함수들을 테스트하고 출력에서 속성이 유지되는지 검증하는 새로운 테스트 도구를 개척하고 있습니다. 이 책의 범위를 벗어나는 내용이지만, 순수 함수 환경에 맞춰 개발된 테스트 도구인 _Quickcheck_ 를 검색해 직접 사용해 보시길 강력히 추천합니다.

### 합리적

많은 사람들이 순수 함수 작업의 가장 큰 이점은 _참조 투명성(referential transparency)_ 라고 믿습니다. 코드의 한 부분이 참조적으로 투명하다는 것은 그것을 평가된 값으로 대체해도 프로그램의 동작이 바뀌지 않는 다는 의미입니다.

순수 함수는 부작용이 없기 때문에 오직 출력 값만을 통해 프로그램의 동작에 영향을 줄 수 있습니다. 게다가 출력 값은 입력 값만으로 신뢰할 수 있게 계산되기 때문에, 순수 함수는 항상 참조 투명성을 유지합니다. 예시를 살펴보겠습니다.

```js
const { Map } = require("immutable");

// Aliases: p = player, a = attacker, t = target
const jobe = Map({ name: "Jobe", hp: 20, team: "red" });
const michael = Map({ name: "Michael", hp: 20, team: "green" });
const decrementHP = (p) => p.set("hp", p.get("hp") - 1);
const isSameTeam = (p1, p2) => p1.get("team") === p2.get("team");
const punch = (a, t) => (isSameTeam(a, t) ? t : decrementHP(t));

punch(jobe, michael); // Map({name:'Michael', hp:19, team: 'green'})
```

`decrementHP`, `isSameTeam` 와 `punch`는 모두 순수 함수이기 때문에 참조 투명성을 가집니다. 이를 통해 _등식적 추론(equational reasoning)_ 이라는 기법을 사용할 수 있습니다. 이는 "같은 것은 같은 것으로 대체할 수 있다"는 개념으로, 코드의 평가 과정을 사람이 직접 따라가며 이해하는 방식입니다. 일반적인 프로그램 실행 환경의 복잡성을 배제하고, 순수하게 코드 자체만을 가지고 논리적으로 추론할 수 있게 해줍니다. 그럼 참조 투명성을 이용해 실제 코드를 조작해보겠습니다.

먼저 `isSameTeam` 함수를 인라인으로 처리해보죠.

```js
const punch = (a, t) => (a.get("team") === t.get("team") ? t : decrementHP(t));
```

우리의 데이터는 불변이기 때문에, 팀 정보를 실제 값으로 대체할 수 있습니다.

```js
const punch = (a, t) => ("red" === "green" ? t : decrementHP(t));
```

이 경우 false이므로 해당 if 분기를 통째로 제거할 수 있습니다.

```js
const punch = (a, t) => decrementHP(t);
```

그리고 `decrementHP` 함수를 인라인으로 처리혐, 이 경우 `punch`는 `hp`를 1만큼 감소시키는 호출이 됨을 알 수 있습니다.

```js
const punch = (a, t) => t.set("hp", t.get("hp") - 1);
```

이처럼 코드를 논리적으로 추론할 수 있는 능력은 리팩토링이나 전반적인 코드 이해에 매우 유용합니다. 사실 우리는 갈매기 무리 프로그램을 리팩토링할 때 이 기법을 활용했습니다. 덧셈과 곱셈의 성질을 이용해 등가 추론을 적용한 것이죠. 실제로 이 책 전반에 걸쳐 이러한 기법들을 계속해서 사용하게 될 것입니다.

### 병렬 처리 가능한 코드

마지막으로, 결정적인 한 방은 바로 이겁니다. 순수 함수는 공유 메모리에 접근할 필요가 없고, 정의상 부수 효과로 인한 경쟁 조건이 발생할 수 없기 때문에 언제든 병렬로 실행할 수 있다는 점입니다.

이러한 병렬 실행은 스레드를 사용할 수 있는 서버 사이드 자바스크립트 환경에서도 가능하고, 웹 브라우저에서는 웹 워커를 통해 가능합니다. 다만 현재 개발 문화에서는 순수하지 않은 함수들과 함께 병렬 처리를 다루는 것이 복잡하기 때문에 다소 꺼려지고 있는 상황입니다.

## 요약

우리는 지금까지 순수 함수가 무엇인지, 그리고 함수형 프로그래머로서 왜 그것을 그렇게까지 중요하게 여기는지를 살펴보았습니다. 앞으로 우리는 모든 함수를 순수하게 작성하려고 노력할 것입니다. 이를 위해 몇 가지 도구들이 필요하겠지만, 당분간은 순수하지 않은 함수와 순수한 코드를 분리해 보겠습니다.

순수 함수로 프로그램을 작성하는 것은 추가적인 도구 없이는 다소 어렵습니다. 데이터를 이리저리 전달하느라 인자를 계속 넘겨줘야 하고, 상태를 사용할 수도 없으며, 효과도 허용되지 않기 때문입니다. 그렇다면 어떻게 이런 '고행과도 같은' 프로그램을 작성할 수 있을까요? 이제 우리는 커리(Curry)라는 새로운 도구를 익히게 될 것입니다.

[Chapter 04: 커링](ch04-kr.md)
