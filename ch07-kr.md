# Chapter 07: 힌들리-밀러(Hindley-Milner)와 나

## 당신은 어떤 타입인가요?

함수형 세계에 처음 입문하셨다면, 머지않아 타입 시그니처에 푹 빠지게 될 것입니다. 타입은 서로 다른 배경을 가진 사람들이 간결하고 효과적으로 소통할 수 있게 해주는 메타 언어입니다. 대부분의 경우, "힌들리-밀너(Hindley-Milner)"라는 시스템을 이용하여 작성하게 되며, 이번 장에서는 이 시스템에 대해 함께 살펴보겠습니다.

순수 함수들을 다룰 때, 타입 시그니처는 영어로는 도저히 표현할 수 없는 강력한 표현력을 지니고 있습니다. 이 시그니처들은 마치 함수의 비밀을 조용히 귀띔해 주는 듯 합니다. 단 한 줄의 간결한 표현만으로 함수의 동작과 의도를 드러낼 수 있습니다. 우리는 이들로부터 "자유 정리(free theormes)"를 도출해낼 수도 있습니다. 타입은 추론될 수 있기 때문에 명시적인 타입 주석이 반드시 필요한 것도 아닙니다. 매우 정밀하게 조정할 수도 있고, 일반적이고 추상적인 형태로 남겨둘 수도 있습니다. 타입은 단지 컴파일 타임에 오류를 잡는 데에만 유용한 것이 아니라, 사실상 최고의 문서 역할을 하기도 합니다. 이처럼 타입 시그니처 함수는 함수형 프로그래밍에서 예상보다 훨씬 더 중요한 역할을 합니다.

JavaScript는 동적 언어이지만, 그렇다고 해서 타입을 전혀 사용하지 않는 것은 아닙니다. 여전히 문자열, 숫자, 불리언 등의 타입을 다루고 있습니다. 다만, 언어 차원에서 통합된 타입 시스템이 존재하지 않기 때문에, 이러한 타입 정보를 머릿속에 기억하고 있어야 할 뿐입니다. 걱정하실 필요는 없습니다. 우리가 문서화를 목적으로 시그니처를 사용하고 있기 때문에, 주석을 활용하여 이를 충분히 대체할 수 있습니다.

JavaScript에는 [Flow](https://flow.org/)나 [TypeScript](https://www.typescriptlang.org/) 같은 타입 검사 도구들도 존재합니다. 하지만 이 책의 목적은 함수형 코드 작성을 위한 도구들을 익히는 것이므로, 함수형 프로그래밍 언어들 전반에서 사용되는 표준 타입 시스템에 초점을 맞춰 설명드리겠습니다.

## 수수께끼의 이야기

먼지 쌓인 수학 서적에서부터, 방대한 학술 논문의 바다를 가로질러, 여유로운 토요일 아침의 블로그 글 속에서 그리고 소스 코드에 이르기까지, 우리는 힌들리-밀러 유형의 타입 시그니처를 발견하게 됩니다. 이 시스템은 비교적 단순하지만, 이 작은 언어를 온전히 익히기 위해서는 간단한 설명과 연습이 필요합니다.

```js
// capitalize :: String -> String
const capitalize = (s) => toUpperCase(head(s)) + toLowerCase(tail(s));

capitalize("smurf"); // 'Smurf'
```

여기서 `capitalize` 함수는 `String`을 받아 `String`을 반환합니다. 구현 내용은 잠시 제쳐두고, 우리가 집중할 부분은 바로 타입 시그니처입니다.

HM 시스템에서는 함수의 타입을 `a -> b` 형태로 표현하며, 여기서 `a`와 `b`는 아무 타입이나 될 수 있는 타입 변수입니다. 따라서 `capitalize`의 시그니처는 "`String`을 받아 `String`을 반환하는 함수"라고 읽을 수 있습니다. 즉, 이 함수는 `String`을 입력으로 받아 `String`을 출력으로 내보냅니다.

이제 몇 가지 함수 시그니처를 더 살펴보겠습니다.

```js
// strLength :: String -> Number
const strLength = (s) => s.length;

// join :: String -> [String] -> String
const join = curry((what, xs) => xs.join(what));

// match :: Regex -> String -> [String]
const match = curry((reg, s) => s.match(reg));

// replace :: Regex -> String -> String -> String
const replace = curry((reg, sub, s) => s.replace(reg, sub));
```

`strLength`는 앞서 본 것과 같은 개념입니다. `String`을 받아 `Number`를 반환합니다.

다른 시그니처들은 처음 보면 다소 당황스러울 수 있습니다. 세부 내용을 완전히 이해하지는 못하더라도, 가장 마지막 타입을 반환값으로 보면 됩니다. 예를 들어, `match`의 경우, "`Regex`와 `String`을 받아 `[String]`을 반환한다"고 해석할 수 있습니다. 하지만 여기에는 흥미로운 점이 하나 있어, 잠시 시간을 내어 설명드리고자 합니다.

`match` 함수의 타입 시그니처는 다음과 같이 그룹화할 수 있습니다 :

```js
// match :: Regex -> (String -> [String])
const match = curry((reg, s) => s.match(reg));
```

아, 맞습니다. 마지막 부분을 괄호로 묶으면 더 많은 정보가 드러납니다. 이제 이 시그니처는 `Regex`를 받아 `String`을 입력으로 받아 `[String]`을 반환하는 함수를 반환하는 함수로 해석됩니다. 커링 덕분에 실제로도 그렇습니다. `Regex`를 하나 주면, 그 다음으로 `String`을 받기 위해 대기하는 함수를 얻게 되는 것이죠.

```js
// match :: Regex -> (String -> [String])
// onHoliday :: String -> [String]
const onHoliday = match(/holiday/gi);
```

각 인자가 주어질 때마다 타입 시그니처의 앞부분에서 하나씩 타입이 사라진다고 생각하시면 됩니다. 즉, `onHoliday`는 이미 `Regex`를 받은 상태의 `match` 함수라고 볼 수 있습니다.

```js
// replace :: Regex -> (String -> (String -> String))
const replace = curry((reg, sub, s) => s.replace(reg, sub));
```

보시다시피 `replace` 함수의 타입 시그니처에 괄호를 모두 명시하려면, 표기가 다소 복잡하고 불필요하게 장황해질 수 있습니다. 그래서 우리는 보통 괄호를 생략합니다. 모든 인자를 한 번에 줄 수도 있기 때문에, 단순하게 생각하는 것이 더 편리합니다. 즉, `replace`는 `Regex`, `String` 또는 다른 `String`을 받아서 최종적으로 `String`을 반환하는 함수라고 보면 됩니다.

마지막으로 몇 가지 더 짚고 넘어가겠습니다 :

```js
// id :: a -> a
const id = (x) => x;

// map :: (a -> b) -> [a] -> [b]
const map = curry((f, xs) => xs.map(f));
```

`id` 함수는 어떤 타입이든 `a`라는 타입을 받아, 동일한 타입 `a`를 그대로 반환합니다. 코드에서 변수명을 사용하는 것처럼, 타입에서도 변수명을 사용할 수 있습니다. `a`,`b` 같은 이름은 관례일 뿐이며, 다른 어떤 이름으로 바꿔도 상관없습니다. 하지만 중요한 규칙이 하나 있습니다. : 같은 타입 변수는 반드시 같은 타입을 의미해야 합니다. 이 점을 다시 강조하겠습니다. `a -> b`는 아무 타입 `a`에서 아무 타입 `b`로 가는 함수일 수 있습니다. 반면 `a -> a`는 반드시 같은 타입이어야 합니다. 예를 들어, `id` 함수는 `String -> String`이나 `Number -> Number`일 수 있지만, `String -> Bool`은 될 수 없습니다.

`map` 함수도 마찬가지로 타입 변수를 사용합니다. 이번에는 `a` 외에 `b`라는 타입을 새로 도입합니다. 이 `b`는 `a`와 같을 수도, 다를 수도 있습니다. 이는 다음과 같이 해석할 수 있습니다 : `map`은 임의의 타입 `a`에서 같은 타입 또는 다른 타입 `b`로 가는 함수를 받고, 그 다음 `a` 타입의 배열을 받아서 `b` 타입의 배열을 결과로 반환합니다.

이 타입 시그니처가 가진 표현력 넘치는 아름다움에 푹 빠지셨기를 바랍니다. 이 시그니처는 함수가 하는 일을 거의 단어 하나하나까지 정확하게 표현하고 있습니다. 타입 시그니처는 `a`에서 `b`로 가는 함수와 `a` 타입의 배열을 받아, `b` 타입의 배열을 반환한다고 말합니다. 그 외의 다른 행동은 명백한 거짓말일 것입니다.

타입과 그 의미에 대해 논리적으로 사고할 수 있는 능력은 함수형 프로그래밍 세계에서 매우 중요한 기술입니다. 이 능력을 갖추면 논문, 블로그, 문서 등이 훨씬 더 쉽게 이해될 뿐 아니라, 타입 시그니처 자체가 마치 기능에 대해 강의하듯 설명해 줍니다. 익숙해지려면 연습이 필요하지만, 꾸준히 노력하면 매뉴얼을 일일이 뒤지지 않아도 풍부한 정보를 얻을 수 잇게 됩니다.

마지막으로, 여러분 스스로 해독해볼 수 있도록 몇 가지 타입 시그니처를 더 소개해 드리겠습니다.

```js
// head :: [a] -> a
const head = (xs) => xs[0];

// filter :: (a -> Bool) -> [a] -> [a]
const filter = curry((f, xs) => xs.filter(f));

// reduce :: ((b, a) -> b) -> b -> [a] -> b
const reduce = curry((f, x, xs) => xs.reduce(f, x));
```

`reduce` 함수는 아마도 가장 표현력이 뛰어난 타입 시그니처를 가진 함수일 것입니다. 다만 다소 까다로운 편이니, 이해하는 데 어려움을 느끼신다고 해서 자신을 부족하게 여기지 마세요. 궁금하신 분들을 위해 영어로 간단히 설명해 드리겠지만, 직접 시그니처를 하나씩 살펴보는 것이 훨씬 도움이 됩니다.

자, 시작해보겠습니다... 시그니처를 보면 첫 번째 인자는 `b`와 `a`를 받아 `b`를 반환하는 함수입니다. 그렇다면 `a`와 `b`는 어디서 오는 것일까요? 다음 인자를 보면 `b`와 `a` 타입의 배열이 들어있으니, 우리는 이 `b`와 배열 속 각각의 `a`가 앞서 말한 함수에 입력된다고 추측할 수 있습니다. 또한 함수의 결과 타입이 `b`인 것도 확인할 수 있는데, 이는 결국 우리가 전달한 함수가 여러 번 호출된 최종 결과가 `reduce`의 반환값이라는 뜻입니다. `reduce`의 동작 방식을 알고 있다면, 이 해석이 정확하다는 것을 알 수 있습니다.

## 가능성의 범위 좁히기

Once a type variable is introduced, there emerges a curious property called _[parametricity](https://en.wikipedia.org/wiki/Parametricity)_. This property states that a function will _act on all types in a uniform manner_. Let's investigate:

일단 타입 변수가 도입되면, 흥미로운 특성인 [매개변수 다형성(parametricity)](https://en.wikipedia.org/wiki/Parametricity)이 나타납니다. 이 특성은 함수가 모든 타입에 대해 일관된 방식으로 동작한다는 것을 의미합니다. 함께 살펴보겠습니다.

```js
// head :: [a] -> a
```

`head` 함수를 보면, `[a]` 타입의 배열을 받아 `a` 타입을 반환합니다. 배열이라는 구체적인 타입 외에는 아무 정보도 제공받지 못하기 때문에, 이 함수는 오직 배열 자체에 대해서만 동작할 수 밖에 없습니다. 타입 변수 `a`에 대해 아무런 정보가 없는데, 그걸 가지고 도대체 무엇을 할 수 있을까요? 다시 말해, `a`는 특정한 타입이 될 수 없고, 따라서 _어떤_ 타입이든 될 수 있다는 뜻입니다. 결과적으로 이 함수는 모든 가능한 타입에 대해 일관되게 동작해야만 합니다. 이것이 바로 _매개변수 다형성(parametricity)_ 의 핵심입니다. 구현을 추측해보면, 합리적인 가정은 배열의 첫 번째 요소나 마지막 요소, 혹은 임의의 요소를 반환하는 것뿐일 겁니다. 함수 이름이 `head`인 점이 힌트가 되겠죠.

다음 예제도 함께 보겠습니다 :

```js
// reverse :: [a] -> [a]
```

타입 시그니처만 보고 `reverse` 함수가 무엇을 할 수 있을지 생각해보면, 역시 `a` 타입에 대해 구체적인 조작은 불가능합니다. 만약 `a`를 다른 타입으로 바꾼다면 새로운 타입 변수 `b`가 도입되어야 하니까요. 정렬을 할 수 있을까요? 그건 불가능합니다. 모든 가능한 타입을 정렬하기 위한 정보가 없기 때문입니다. 배열의 요소를 재배열하는 것은 가능하겠지만, 반드시 똑같고 예측 가능한 방식이어야 합니다. 또는 어떤 요소를 제거하거나 중복시키는 동작도 있을 수 있습니다. 어쨌든 중요한 점은, 다형성 타입(polymorphic type)이 가능성의 범위를 크게 좁혀준다는 것입니다.

이러한 가능성의 제한 덕분에 우리는 [Hoogle](https://hoogle.haskell.org/)같은 타입 시그니처 검색 엔진을 활용해 원하는 함수를 쉽게 찾을 수 있습니다. 시그니처에 촘촘히 담긴 정보가 얼마나 강력한지 알 수 있는 대목입니다.

## 정리학적으로 얻는 자유(Free as in Theorem)

구현 가능한 가능성을 추론하는 것 외에도, 이러한 사고 방식은 우리에게 _자유 정리(free theorems)_ 라는 중요한 결과를 선사합니다. 다음 [Wadler의 관련 논문](http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf)에서 직접 발췌한 몇 가지 예시를 함께 살펴봅시다.

```js
// head :: [a] -> a
compose(f, head) === compose(head, map(f));

// filter :: (a -> Bool) -> [a] -> [a]
compose(map(f), filter(compose(p, f))) === compose(filter(p), map(f));
```

이 정리들을 도출하는 데 코드는 필요하지 않습니다. 타입만으로도 바로 도출할 수 있습니다. 첫 번째 정리는, 배열에서 `head`를 먼저 구한 뒤 함수 `f`를 적용하는 것과 배열 전체에 `map(f)`를 먼저 적용한 후 결과에서 `head`를 구하는 것과 동일하다는 내용을 담고 있습니다. 게다가 전작 훨씬 더 빠르죠.

"그건 당연한 이야기 아니야?"라고 생각할 수 있지만, 컴퓨터에는 그런 상식이 없다는 점이 중요합니다. 컴퓨터는 이런 종류의 코드 최적화를 자동화하기 위해 반드시 형식적인 방법이 필요합니다. 수학은 직관적인 개념을 형식화하는 역할을 하며, 이는 엄격한 컴퓨터 논리의 영역에서 매우 유용합니다.

`filter` 정리도 비슷한 맥락입니다. 함수 `f`와 조건 판별함수 `p`를 합성하여 어떤 요소를 필터링할지 결정한 다음, `map`으로 `f`를 적용하는 것이 (참고로 `filter`는 요소 자체를 변형하지 않으므로 `a` 타입을 변경하지 않습니다) `f`를 먼저 맵핑하고 그 결과를 `p` 조건으로 필터링하는 것과 항상 동일하다고 말합니다.

이 두 가지는 단지 예시일 뿐이며, 이런 추론은 모든 다형성 타입 시그니처에 적용 가능하고 항상 성립합니다. 자바스크립트에도 이런 재작성 규칙을 선언할 수 있는 도구들이 있습니다. 또는 `compose` 함수 자체를 이용해 이 작업을 수행할 수도 있죠. 성과는 쉽게 얻을 수 있고, 가능성은 무한하다고 할 수 있습니다.

## 제약 조건

마지막으로 알아둘 점은, 타입에 인터페이스를 제약 조건으로 걸 수 있다는 것입니다.

```js
// sort :: Ord a => [a] -> [a]
```

위 타입 시그니처에서 화살표 왼쪽에 있는 부분은 일종의 조건을 나타냅니다 : `a`는 반드시 `Ord` 타입 클래스를 구현해야 한다는 뜻입니다. 즉, `a`가 `Ord` 인터페이스를 만족해야 한다는 의미죠. 그렇다면 `Ord`는 무엇이며, 어디서 온 걸까요? 타입이 명시된 언어에서는 `Ord`가 "값들을 정렬할 수 있다"는 기능을 정의한 인터페이스입니다. 이 제약은 `a`에 대해 더 많은 정보를 제공할 뿐 아니라, `sort` 함수가 작동하는 값들의 범위를 제한합니다. 이런 인터페이스 선언을 우리는 _타입 제약_ 이라고 부릅니다.

```js
// assertEqual :: (Eq a, Show a) => a -> a -> Assertion
```

여기서는 두 가지 제약 조건이 붙어 있습니다. `Eq`와 `Show`. 이 조건들은 `a` 타입 값들 간에 동등성을 비교할 수 있고, 만약 다를 경우 차이를 출력할 수 있음을 보장합니다.

앞으로 더 많은 제약 조건 예제를 보게 될 것이며, 이러한 개념은 이후 챕터에서 더욱 명확해질 것입니다.

## 요약

힌들리-밀러 타입 시그니처는 함수형 프로그래밍 세계에서 매우 널리 사용됩니다. 읽고 쓰는 것은 간단하지만, 시그니처만으로 프로그램을 이해하는 능력을 익히는 데 시간이 걸립니다. 이제부터는 모든 코드에 타입 시그니처를 함께 작성하면서 이 기술을 익혀보겠습니다.

[Chapter 08: Tupperware](ch08-kr.md)
